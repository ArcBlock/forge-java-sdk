apply plugin: 'java'
import groovy.text.GStringTemplateEngine
import groovy.text.SimpleTemplateEngine

import java.util.function.Consumer


class genForgeABI extends DefaultTask {
  @TaskAction
  def genClient(){
    def protobuf = project.file(project.rootDir.path+"/src/main/proto/service.proto")
    HashMap<String,ArrayList<HashMap<String,String>>> serverMap =new HashMap()
    if(protobuf.canWrite()){
      def curStr = ""
      ArrayList<HashMap<String,String>> list =new ArrayList<>()
      def halfline = ""
      boolean  begined= false
      protobuf.readLines().forEach(new Consumer<String>() {
        @Override
        void accept(String s) {
          if (s.isEmpty()) return
          s = s.trim()
          if(s.startsWith("//")) return
          if (s.trim().startsWith("service")){
            begined = true
            curStr = s.replace("service","").replace("{","").trim()
            list.clear()
          }else if (begined){
            if(s.trim().startsWith("rpc")){
              if(s.contains(";")){
                list.add(decodeMethod(s))
              }else {
                halfline = halfline+s
              }
            }else if(s.trim().startsWith("}")){
              serverMap[curStr] = list
            }else if(s.contains(";")){
              halfline = halfline+s
              list.add(decodeMethod(halfline))
              halfline = ""
            }else {
              halfline = halfline+s
            }
          }
        }
      })
      println("ret: $serverMap")
      generateJava()

    }
  }

  void generateJava(HashMap<String,ArrayList<String,HashMap<String,String>>> map){

  }


  HashMap<String,String> decodeMethod(String line){
    println("line:$line")
    HashMap<String,String> ret = new HashMap<>()
    def slice = line.split("returns")
    int firstLeft = slice[0].indexOf("(")
    int firstRight = slice[0].indexOf(")")
    ret["med"]=camelName(slice[0].substring(3,firstLeft))
    ret["param"]=slice[0].substring(firstLeft+1,firstRight).replace("stream","")
    int lastLeft = slice[1].indexOf("(")
    int lastRight = slice[1].indexOf(")")
    ret["ret"]=slice[1].substring(lastLeft+1,lastRight).replace("stream","")
    if(line.contains("stream")){
      ret["stream"] ="stream"
    }
    ret
  }


/**
 * 将下划线大写方式命名的字符串转换为驼峰式。如果转换前的下划线大写方式命名的字符串为空，则返回空字符串。</br>
 * 例如：HELLO_WORLD->HelloWorld
 *
 * @param name 转换前的下划线大写方式命名的字符串
 * @return 转换后的驼峰式命名的字符串
 */
  public static String camelName(String name) {
    StringBuilder result = new StringBuilder();
    // 快速检查
    if (name == null || name.isEmpty()) {
      // 没必要转换
      return "";
    } else if (!name.contains("_")) {
      // 不含下划线，仅将首字母小写
      return name.substring(0, 1).toLowerCase() + name.substring(1);
    }
    // 用下划线将原始字符串分割
    String[] camels = name.split("_");
    for (String camel : camels) {
      // 跳过原始字符串中开头、结尾的下换线或双重下划线
      if (camel.isEmpty()) {
        continue;
      }
      // 处理真正的驼峰片段
      if (result.length() == 0) {
        // 第一个驼峰片段，全部字母都小写
        result.append(camel.toLowerCase());
      } else {
        // 其他的驼峰片段，首字母大写
        result.append(camel.substring(0, 1).toUpperCase());
        result.append(camel.substring(1).toLowerCase());
      }
    }
    return result.toString();
  }
}


